# 1121 교육내용
## Memo
 우리가 메모장에 뭘 메모한다는 뜻의 memo가 아니라 Memoization의 Memo이고 전체적인 실행속도를 올리는 방법이다.</br>
 메모의 대상은 컴포넌트이다. 메모리에 있는 컴포넌트를 재실행하는 것이다. </br>
 props나 state가 변경되면 자식으로 있는 provider는 무조건 재실행되는데 이것을 막아주는 방법이다. </br>
 export memo(function)로 감싸서 처음 실행했을 때만 실행되게하고 메모리에 저장시키고, 필요할 때만 재실행한다.</br>
 재실행하는 기준은 component에 전달되는 props가 변경되었을 때만, 컴포넌트를 다시 실행시킨다.</br>
 이 때, 의문점이 하나 생기는데 state는 다시 실행되면서 초기값이 다시 할당되는 것 아닌가? >>> useState도 메모리로 관리하기 때문에 처음 실행할 때만 초기값을 넣어준다.</br>
 정말 필요할 때(컴포넌트 하나가 10초 넘게 걸려서 실행되는 경우 등)만 써야한다. 너무 많이 쓰면 오히려 성능 저하를 일으킨다.</br>
## UseCallback
 함수는 객체라서 props로 전달하게되면 memo를 사용한다고 해도 다시 실행한다.</br>
 p.207을 참조하여 useCallback에서 어째서 () => {함수와 , []} 형태로 나오는지 확인할 수 있다. [aState]가 들어가 있다면 aState가 바뀌면 함수를 다시 만들라는 뜻이다. </br>


* 우리가 Memo를 안쓰고 최적화를 잘하는 방법은 컴포넌트의 구조를 분리하는 것을 잘 하면된다. addtodo에서 alert다시 시작 안하게 하는 것마냥 간섭을 안하도록 구조를 잘 만드는 것도 참 중요하다.</br>

 ## fetch
  
