# 1121 교육내용
## Memo
 우리가 메모장에 뭘 메모한다는 뜻의 memo가 아니라 Memoization의 Memo이고 전체적인 실행속도를 올리는 방법이다.</br>
 메모의 대상은 컴포넌트이다. 메모리에 있는 컴포넌트를 재실행하는 것이다. </br>
 props나 state가 변경되면 자식으로 있는 provider는 무조건 재실행되는데 이것을 막아주는 방법이다. </br>
 export memo(function)로 감싸서 처음 실행했을 때만 실행되게하고 메모리에 저장시키고, 필요할 때만 재실행한다.</br>
 재실행하는 기준은 component에 전달되는 props가 변경되었을 때만, 컴포넌트를 다시 실행시킨다.</br>
 이 때, 의문점이 하나 생기는데 state는 다시 실행되면서 초기값이 다시 할당되는 것 아닌가? >>> useState도 메모리로 관리하기 때문에 처음 실행할 때만 초기값을 넣어준다.</br>
 정말 필요할 때(컴포넌트 하나가 10초 넘게 걸려서 실행되는 경우 등)만 써야한다. 너무 많이 쓰면 오히려 성능 저하를 일으킨다.</br>
## UseCallback
 함수는 객체라서 props로 전달하게되면 memo를 사용한다고 해도 다시 실행한다.</br>
 p.207을 참조하여 useCallback에서 어째서 () => {함수와 , []} 형태로 나오는지 확인할 수 있다. [aState]가 들어가 있다면 aState가 바뀌면 함수를 다시 만들라는 뜻이다. </br>


* 우리가 Memo를 안쓰고 최적화를 잘하는 방법은 컴포넌트의 구조를 분리하는 것을 잘 하면된다. addtodo에서 alert다시 시작 안하게 하는 것마냥 간섭을 안하도록 구조를 잘 만드는 것도 참 중요하다.</br>

## fetch
  promise의 응답데이터를 전송받기 위해서 ,then().then()을 이용했으나, 길어지게 되면 너무 불편해서 async / await을 이용하여 비동기 통신을 구현한다.(교재 200)</br>
  추가적으로 async는 비동기 통신이라는 것을 명시하며, await는 통신이 끝날때까지 대기한다는 것이다.</br>

## Side Effect
 개발자가 아는 Side Effect는 버그를 잡기위해서 수정을 해서 다른 오류가 생성되는 것을 말한다.</br>
 react에서는 의미가 조금 다르다. 어떤 함수가 실행되어 화면에 변화가 일어나는 것을 말한다.</br>
 이것을 막기 위해서 사용하는 것이 useEffect이다.</br>


 비동기 통신은 동시에 함수가 실행될 수 있기 때문에, setState로 state변환이 언제끝날지 모른다. 그래서 초기값이 없으면 중간에 메세지가 생길 것이기 때문에 오류가 생기지 않도록 초기값을 넣어주고, setState가 완료되면 다시 렌더링된다.</br>

## 게시판 실습
객체 리터럴과 JSON은 다른 타입이다. 그러므로 객체 리터럴을 ```JSON.stringify({ email: email, password: password })```처럼 JSON으로 바꿔주어야 한다. </br>

